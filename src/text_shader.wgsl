struct VertexInput{@location(0)position:vec3<f32>,@location(1)character:u32}struct VertexOutput{@builtin(position)clip_position:vec4<f32>,@location(0)character:u32,@location(1)uv:vec2<f32>}@vertex fn vs_main(input:VertexInput,@builtin(vertex_index)index:u32)->VertexOutput{var output:VertexOutput;output.clip_position=vec4<f32>(input.position,1.0);output.character=input.character;switch(index%4u){case 0u:{output.uv=vec2<f32>(1.0,0.0);}case 1u:{output.uv=vec2<f32>(0.0,0.0);}case 2u:{output.uv=vec2<f32>(0.0,1.0);}default:{output.uv=vec2<f32>(1.0,1.0);}}return output;}@group(0)@binding(0)var<storage>buf:array<u32>;@fragment fn fs_main(output:VertexOutput)->@location(0)vec4<f32>{let x=u32(output.uv[0]*16.0);let y=u32(output.uv[1]*16.0);let offset=(output.character&0x00FFFFFFu)*32u;let index=offset+y*2u+x/8u;let a=(((buf[index/4u]>>((index%4u)*8u))&0xFFu)>>(7u-x%8u))&1u;var color=0.0;var alpha=0.0;if(a>0u){color=f32(output.character>>24u)/255.0;alpha=1.0;}return vec4<f32>(color,color,color,alpha);}